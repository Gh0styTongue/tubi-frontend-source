"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.middleware = exports.getOngoingFetch = exports.shouldFetch = exports.resetDescriptors = exports.createDescriptors = exports.isCacheValid = exports.getTTL = exports.createActionTypes = void 0;
var types_1 = require("./types");
var utils_1 = require("./utils");
var ongoingFetchMap = {};
var DEFAULT_VALID_DURATION_SECONDS = 24 * 60 * 60; // 1 day in second
/**
 * Construct action types to facilitate and normalize fetch action types.
 */
var createActionTypes = function (base) { return Object.keys(types_1.StatusSuffix)
    .reduce(function (names, status) {
    names[status] = "".concat(base, "_").concat(status);
    return names;
}, { BASE: base }); };
exports.createActionTypes = createActionTypes;
/**
 * calculate ttl with given validDuration in seconds
 * @param {number} validDuration in second
 * @returns {number} ttl in millisecond
 */
var getTTL = function (validDuration) {
    return Date.now() + validDuration * 1000;
};
exports.getTTL = getTTL;
/**
 * check whether cache is still valid
 * @param {number | undefined} ttl the ttl generated by getTTL method
 */
var isCacheValid = function (ttl) { return ttl !== undefined && ttl >= Date.now(); };
exports.isCacheValid = isCacheValid;
/**
 * Generate descriptor fields used in redux store for fetch operations, including `isFetching`/`error`/`ttl`.
 * For example, `isFetching` represents the current fetch operation is ongoing and we can avoid unnecessary fetch by using it.
 * Another example is, `ttl` can be used to evaluate whether the data last fetched is still fresh enough.
 *
 * @param action redux action
 * @param validDuration how much time the data will be valid, in seconds.
 */
var createDescriptors = function (action, validDuration) {
    if (validDuration === void 0) { validDuration = DEFAULT_VALID_DURATION_SECONDS; }
    var fetchId = action.fetchId, payload = action.payload, type = action.type;
    var suffix = type.split('_').pop();
    switch (suffix) {
        case types_1.StatusSuffix.FETCH:
            return {
                isFetching: true,
                fetchId: fetchId,
            };
        case types_1.StatusSuffix.SUCCESS:
            return {
                isFetching: false,
                ttl: (0, exports.getTTL)(validDuration),
                error: null,
            };
        case types_1.StatusSuffix.FAILURE:
            return {
                isFetching: false,
                error: payload,
            };
        default:
            return {};
    }
};
exports.createDescriptors = createDescriptors;
/**
 * reset all fetch descriptors in redux store
 */
var resetDescriptors = function () { return ({
    isFetching: false,
    ttl: undefined,
    error: null,
}); };
exports.resetDescriptors = resetDescriptors;
/**
 * Evaluate whether to fetch data based on fetch descriptors in store state.
 * return false if there cache is still valid or there is ongoing request
 */
var shouldFetch = function (state) {
    // avoid to fetch again when there is an ongoing fetch
    if (state.isFetching)
        return false;
    if (state.error)
        return true;
    return state.ttl ? !(0, exports.isCacheValid)(state.ttl) : true;
};
exports.shouldFetch = shouldFetch;
/**
 * Retrieve in progress fetch promise by `fetchId`
 */
var getOngoingFetch = function (state) {
    var fetchId = state.fetchId;
    return (typeof fetchId !== 'undefined' && ongoingFetchMap[fetchId]) ? ongoingFetchMap[fetchId] : Promise.resolve();
};
exports.getOngoingFetch = getOngoingFetch;
/**
 * Redux middleware to handle fetch operation specifically.
 * All actions dispatched here follow FSA standard.
 */
var middleware = function () { return function () { return function (next) { return function (action) {
    var payload = action.payload, type = action.type, rest = __rest(action, ["payload", "type"]);
    if (!payload || !type.FETCH) {
        return next(action);
    }
    var fetchId = (0, utils_1.genUuid)();
    next(__assign(__assign({}, rest), { type: type.FETCH, fetchId: fetchId }));
    // execute fetch operation
    var promise = payload();
    // reserve it to be used for subscriptions who wait until it settles
    ongoingFetchMap[fetchId] = promise;
    return promise.then(function (result) {
        delete ongoingFetchMap[fetchId];
        next(__assign(__assign({}, rest), { type: type.SUCCESS, payload: result }));
        return result;
    }, function (error) {
        delete ongoingFetchMap[fetchId];
        next(__assign(__assign({}, rest), { type: type.FAILURE, payload: error, error: true }));
        throw error;
    });
}; }; }; };
exports.middleware = middleware;
//# sourceMappingURL=index.js.map